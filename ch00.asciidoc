[preface]
[[PREFACE]]
Preface
-------

Erlang has long been a mysterious dark corner of the programming universe, visited mostly  by developers who need extreme reliability or scalability and people who want to stretch their brains. 

Developed at Ericsson to serve on telephone switching equipment, it seemed like a strangely special-purpose language until recently, when our computer and network architectures came to look a lot more like massively parallel telephone-switching equipment. Thanks to the rise of NoSQL data stores CouchDB and Riak, you may already be using Erlang without realizing it, and Erlang is moving out into many more fields.

Exploring Erlang, if you come from pretty much any background other than functional programming, will require you to clear your mind of many techniques used in other programming languages.  Forget classes, forget variables that change values - even forget the conventions of how assigning values to variables works.

Instead, you're going to have to think about pattern matching, message passing, and establishing pathways for data rather than telling it where to go.  Erlang programming can feel like making a key whose teeth set the tumblers on a lock just right for the key to pass, or playing pachinko and watching the balls fall through a maze.

Sound strange?  It is - but also enjoyable, powerful, and fun.

My first explorations of Erlang confused me and excited me at the same time.  I'd had some experience with what I'd called "invariant variables", variables that can only be bound to a value once, in XSLT.  That had created a lot of headaches for me until I realized I was coming at the problems all wrong, and then it suddenly made sense.



Who This Book is For
~~~~~~~~~~~~~~~~~~~~

This book is mostly for people who've been programming in other languges who want to look around.  Maybe you're being very practical, and Erlang's distributed model and the resulting scale and resilence advantages appeal to you.  Maybe you want to see what this "functional programming" stuff is all about.  Or maybe you're just going for a hike, taking your mind to a new place.

I suspect that functional programming is more approachable as a first language, before you've learned to program in other paradigms.  However, getting started in Erlang - sometimes even just installing it - requires a fair amount of computing skill.  If you're a complete newcomer to programming, welcome, but there will be a few challenges along the way.


Who This Book is Not For
~~~~~~~~~~~~~~~~~~~~~~~~

This book is not for people in a hurry to get things done.

If you already know Erlang, you don't likely need this book unless you're looking for a slow brush-up.

If you're already familiar with functional languages, you may find the pacing of this "Gentle Introduction" hopelessly slow.  Definitely feel welcome to jump to another book that moves faster if you get bored.  Come back if you find the others go too fast, and definitely feel welcome to use this as a companion guide or reference with the other books.


What This Book Will Do For You
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In _Seven Languages in Seven Weeks_, Bruce Tate suggests that "Erlang makes hard things easy and easy things hard."  This book will get you through the "easy things hard" part, and show you a bit of the promised land of "hard things easy".

In practical terms, you'll learn to write simple Erlang programs.  You'll understand why Erlang makes it easier to build resilient programs that can scale up and down with ease.  Perhaps most importantly, you'll be able to read other Erlang resources that assume a fair amount of experience and make sense of them.

In more theoretical terms, you'll get to know functional programming.  You'll learn how to design programs around message-passing and recursion, creating process-oriented programs focused more on data flow.

You'll also be better prepared to read other books and conversations about Erlang.


How This Book Works
~~~~~~~~~~~~~~~~~~~

This book tries to tell a story with Erlang.  This means that you'll probably get the most out of it if you read it in order at least the first time, though you're always welcome to come back to find whatever bits and pieces you need.

You'll start by getting Erlang installed and running, and look around its shell.  You'll spend a lot of time in the shell, so get cozy.  Next, you'll start loading code into the shell to make it easier to write programs, and you'll learn how to call that code and mix it up.

Next, you'll take a close look at numbers, because they're an easy place to get familiar with Erlang's basic structures.  Next you'll learn about atoms, pattern-matching, and guards - the likely foundations of your program structure.    After that you'll learn about strings, lists, and the recursion at the heart of much Erlang processing.  Once you've gone a few million recursions down and back, it'll be time to look at processes, a key part of Erlang that relies on the message-passing model to support concurrency and resilience.

Once you have the foundation set, you can take a closer look at debugging and data storage, and then get a quick look at a toolset which is likely at the heart of your long-term development with Erlang: the Open Telecom Platform (OTP), which is about much much more than telephones.

Some people want to learn programming languages through a dictionary.  Here's a list of operators, here's a list of control structures, these are the datatypes - and then smash them together.  Those lists are here, but they're in <<APPENDIX>>, not the main flow of the book.

The main point you should get from this book is that you can program in Erlang.  If you don't get that, let me know!

Why I Wrote This Book
~~~~~~~~~~~~~~~~~~~~~

I'm not an Erlang expert hoping to create more Erlang experts to get a lot of work done.  

I'm a developer and writer who encountered Erlang, thought it was the programming language I'd been seeking for a long time, and felt compelled to share some of that.  I'm hoping that the path I followed will work for other people, probably with variations, and that a book written from a beginner's perspective (and vetted by experts) would help more people find and enjoy Erlang.


Other Resources
~~~~~~~~~~~~~~~

This book may not be the best way for you to learn Erlang.  It all depends on what you want to learn and why.  

If your primary interest in learning Erlang is to break out of a programming rut,  you should definitely explore Bruce Tate's wild tour of _Seven Languages in Seven Weeks_ (Pragmatic Publishers), which explores Ruby, Io, Prolog, Scala, Erlang, Clojure, and Haskell.  Erlang only gets (an excellent) 37 pages, but that might be what you want.

For an online experience (soon to be in print from No Starch Books) with more snark and much funnier illustrations, you should explore Fred Hebert's _Learn You Some Erlang for Great Good!_, at  http://learnyousomeerlang.com/.  While much longer than Tate's telling, it certainly moves faster and may feel more like an experienced programmer's guide to Erlang.

The two classic general books on Erlang are the similarly-titled _Programming Erlang_ (Pragmatic Publishers), by Erlang creator Joe Armstrong, and _Erlang Programming_ (O'Reilly Media, Inc.) by Francesco Cesarini and Simon Thompson.  They cover a lot of similar and overlapping terrain, and both may be good places to start if this moves too slowly or you need more reference material.  _Erlang Programming_ goes further into what you can do with Erlang, while _Programming Erlang_ provides a lot of detail on setting up an Erlang programming environment.

On the more advanced side, _Erlang and OTP in Action_ (Manning), by Martin Logan, Eric Merritt, and Richard Carlsson, opens with a high-speed 72-page introduction to Erlang and then spends most of its time applying the Open Telecom Platform, Erlang's framework for building upgradeable and maintainable concurrent applications.

If you want to focus on connecting Erlang to the Web, you should definitely also explore _Building Erlang Web Applications_ (O'Reilly), by Zachary Kessin.

You'll also want to visit the main Erlang web site, http://www.erlang.org/, for updates, downloads, documentation, and more.

Are You Sure You Want Erlang?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Though they've been obscure for a long time, there's a crowd of functional languages rising into greater popularity.

Three of them in particular - Clojure, F#, and Haskell - may be more appealing than Erlang if you have specific needs.  

* Clojure runs on the Java Virtual Machine (JVM), making it insanely portable, and has access to Java libraries as a result.  ClojureScript does the same with JavaScript, too. (Erjang makes it possible to run Erlang on the JVM, but it's not a core part of the language.) 

* F# runs on the .NET Common Language Runtime (CLR), making it very portable in the Microsoft ecosystem, and again, has access to .NET libraries.

* Haskell doesn't run on a virtual machine, but also offers a stronger type system and a different kind of discipline (and laziness).

Personally, I got my start with these concepts in XSLT.  It's a very different kind of language, meant for a specific domain of document transformation, but many of the same ideas flow through it.

You don't, of course, have to decide if Erlang is your life's dream now.  You can learn concepts in Erlang and apply them elsewhere if it turns out to be a better idea for your work.

Erlang Will Change You
~~~~~~~~~~~~~~~~~~~~~~

Before you go deeper, you should know that working in Erlang may change, irrevocably, the way you look at programs.  Its combination of functional code, process-orientation, and distributed development may seem alien at first.  However, once it sinks in, Erlang can transform the way you solve problems, and potentially make it difficult to return to other languages, environments, and programming cultures.

Conventions Used in This Book
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The following typographical conventions are used in this book:

_Italic_:: Indicates new terms, URLs, email addresses, filenames, and file extensions.

+Constant width+:: Used for program listings, as well as within paragraphs to refer to program elements such as variable or function names, statements, and keywords.

**`Constant width bold`**:: Shows commands or other text that should be typed literally by the user.

_++Constant width italic++_:: Shows text that should be replaced with user-supplied values or by values determined by context.

NOTE: This icon signifies a tip, suggestion, or general note.


WARNING: This icon indicates a warning or caution.


A Note on Erlang Syntax
~~~~~~~~~~~~~~~~~~~~~~~

Erlang's syntax seems to be a sticking point for a lot of people.  It doesn't look like the C family of languages.  Punctuation is different and capitalization matters.  Periods even get used as conclusions rather than connectors!

To me, Erlang syntax mostly feels natural, and I'm especially happy that it's different from the other languages I typically use.  I make a lot fewer mix-ups that way.

Rather than dwell on syntax, I've chosen just to present it as it is.  Comparing it to other languages doesn't seem likely to be helpful, especially when different readers may come from different programming backgrounds.  Hopefully you will find Erlang syntax as pleasant as I do.

Examples
~~~~~~~~

The examples in this book are meant to teach basic concepts in small bites.  While you may certainly borrow code and reuse it as you see fit, you won't be able to take the code of this book and build a stupendous application instantly (unless perhaps you have an unusual fondness for calculating the speeds of falling objects).  You should, however, be able to figure out the steps you need to take to build a great application.

You can download the code from the Examples link on the book's page at http://shop.oreilly.com/product/0636920025818.do .

This book is here to help you get your job done. In general, you may use the code in this book in your programs and documentation. You do not need to contact us for permission unless you are reproducing a significant portion of the code. For example, writing a program that uses several chunks of code from this book does not require permission. Selling or distributing a CD-ROM of examples from O'Reilly books does require permission. Answering a question by citing this book and quoting example code does not require permission. Incorporating a significant amount of example code from this book into your product's documentation does require permission.

We appreciate, but do not require, attribution. An attribution usually includes the title, author, publisher, and ISBN. For example: "_Introducing Erlang_, by Simon St.Laurent (O'Reilly). Copyright 2012 Simon St.Laurent, 9781449331764."  

If you feel your use of code examples falls outside fair use or the permission given above, feel free to contact us at pass:[<email>permissions@oreilly.com</email>].

Help This Book Grow
~~~~~~~~~~~~~~~~~~~

While I hope that you will enjoy reading this book and learn from it, I also hope that you can contribute to helping other readers learn Erlang here.  You can help your fellow readers in a number of ways:

* If you find specific technical problems, bad explanations, or things that can be improved, please report them through the errata system at http://oreilly.com/catalog/errata.csp?isbn=0636920025818.

* If you like (or don't like) the book, please leave reviews.  The most visible places to do so are on Amazon.com (or its international sites) and at the O'Reilly page for the book at http://shop.oreilly.com/product/0636920025818.do.  Detailed explanations of what worked and what didn't work for you (and the broader target audience of programmers new to Erlang) are helpful to other readers and to me.

* If you find you have much more you want to say about Erlang, please consider sharing it, whether on the Web, in a book of your own, in training classes, or in whatever form you find easiest.

I'll update the book for errata, and try to address issues raised in reviews. Even once the book is 'complete', I may still add some extra pieces to it.  If you purchased it as an ebook, you'll receive these updates for free at least up to the point where it's time for a whole new edition.  I don't expect that new edition declaration to come quickly, however, unless the Erlang world changes substantially.

Hopefully this book will engage you enough to make you consider sharing.

Please Use It For Good
~~~~~~~~~~~~~~~~~~~~~~

I'll let you determine what "good" means, but think about it.  Please try to use Erlang's power for projects that make the world a better place, or at least not a worse place.

Acknowledgments
~~~~~~~~~~~~~~~

Many thanks to Zachary Kessin for interesting me in Erlang in the first place, and to him and Francesco Cesarini for encouraging me to write this.  Detailed feedback from Steve Vinoski and Fred Hebert has made it possible, I hope, for this book to get readers started on the right track.  J. David Eisenberg and Chuck Ha helped make it especially possible for beginners to get started right, pointing out gaps and issues in my prose.

In particular, thanks to my wife Angelika for encouraging me to finish this, to my son Konrad for not throwing the printouts around too much, and to my daughter Sungiva for understanding that I needed to go back downstairs after I told her her story about Ned and Ernie, adventuring snakes, for the night.